{"./":{"url":"./","title":"Introduction","keywords":"","body":"Unity 记录了笔者学习Unity的过程与知识。 "},"UnityDailyLearn.html":{"url":"UnityDailyLearn.html","title":"Unity面试题记录","keywords":"","body":"Unity每日一讲 Day1 跑猪问题 ​ 题目： 官方思路： ①每头猪至少需要跑一次 ②避免重复 ③六场一共完成了36头猪的赛跑，每场赛跑记下这些猪的名次。 ④进行第七场，得出的六头猪中的后三头代表的小组会被淘汰。因为后三头代表的小组头名都没有进入前三的话，则整组都不能进入前三名。 第一种思路： ⑤有可能在这第一头所在的组中有比第二、第三头猪跑的更快的猪出现。 ​ 所以第八场，将第一头所在的组中的第二、三名选出，与第二头所在的组中的第二选出，与第三头比较。得出最快的三头 ⑥最后的第九组，将这三头与没跑过的三头猪进行比较，得出前三名。 第二种思路： ⑤将前三头最快的猪与未跑的猪进行相比，得出最快的三头，如果最快的三头来自未跑过的猪，则前三名确定。只需8场就能完全测试出来。 ⑥如果前三名中同时含有未跑过的猪和跑过的猪，则按照上种思路排列。注意：出现这种情况下，第九场可能赛跑的猪并不到六只。举例：当跑第一的猪为未跑过的猪，则其不需要再选出其余的第二第三头猪，第二名的猪如来自跑过的猪，则在里面选取其组内的第二名。第三头则不需要选择。 Day2 堆还是栈 当这个类实例化后，其成员member，它存储在堆上，还是在栈上？ public class Bar{ public int member; } 答：在堆上 ①解释什么是堆，什么是栈 堆，存储所有的对象 栈，存储临时的值类型和引用，离开方法域就失效 举例： public class Bar{ public int member; public Bar friend; } void somFunc(){ Bar bar = new Bar(); bar.member = 1; } 在方法体中，创建了新的Bar对象，该对象类似于指针，存储在栈上，指向堆的一个内存空间。 bar.member = 1，因为bar在堆上开辟了内存空间，所以bar内部所有的成员都存储在堆上，故bar.member的值也存储在堆上。 易错点： 值类型存储在栈上，这是错误的片面的说法。栈上只有临时引用对象，它离开该方法域就会消失。但是在该例子中该值类型为类的成员，是需要持久化的，故不会存储在栈上。 扩展： GC（Garbage Collection）垃圾回收，懂得堆栈的原理可以帮助我们选择垃圾回收的时间。 GC的产生源自我们对堆内存空间的开辟，如new一个对象，无论是显式的还是隐式的。而临时的栈变量则不存在GC。而一旦值类型放入了对象当中，在对象new出来的时候，就会占据相应的堆内存空间，要等待垃圾回收的时候才能回收掉。 Day3 通用api设计 题目： （本题目不考虑热更新，热更新需尽量少用泛型） 选用泛型。 可变参数列表实质： 将传进来的参数变成一个数组(params object[])，并传入函数当中 在此过程中，产生了一个新的数组 new就是GC，这里已经产生了GC 此处发生了装箱boxing（int x = 5; FuncName(x)）,也会产生GC 因产生GC的问题十分严重，故不采用可变参数列表 总结： 这类题主要考验的是不同设计模式所造成的后果，避免采用后果过于严重的设计模式。 Day4 显示与隐藏 题目： 应该选用移动位置。 SetActive(true)和SetActive(false)做了什么： SetActive(true)会使当前物体上挂载的所有脚本，OnEnable()调用一次 SetActive(false)同样的，OnDisable()调用一次 递归向下，所有的子物体都会做同样的处理 但与此同时，所有脚本Update() LateUpdate()等的消耗被清零了 Transform.position=?又做了什么： 对位置进行了移动 所有子物体同时发生了位置上的变化 如果不再做额外的处理，Update() LateUpdate()等会继续执行 在频繁显示隐藏的情况下： Update()和LateUpdate()的体消耗难以避免 因为OnEnable()和OnDisable()很多脚本初始化时都会进行调用 移动位置的方式其实也并不理想 可能影响大量物体的位置矩阵 很多地方都有可能修改位置，随意进行位置移动可能导致大量难以朔源的Bug 更为理想的方式： ①修改GameObjectd的layer，使得它在相机的Culling Mask之外，使相机不再渲染此物体。 ②获取MeshRender.enabled = true/false，自身的OnEnable()和OnDisable()会被调用，但是其他不会被调用。 其中MeshRender.enabled = false的方式更好一些，因为该方法与其他逻辑耦合度更低。 Day5 活用整形 题目： 答案为整形int 整数的位组成： 一个int32是4个字节，32位 用二进制来表示是0000 0000 0000 0000 0000 0000 0000 0000 如果每一位我们可以表示一个布尔状态，即用0表示无此状态，用1表示有此状态，那不就可以用一个整形表示32个状态了吗【有符号整形31，无符号整形32】 示例 0001 状态1 0010 状态2 0100 状态3 1000 状态4 0011=>0010 | 0001 表示状态1与状态2同时存在（位或），位或指的是某一位之间进行或运算，全为0则取0，有1就取1 Enum State{ State1 = 0, State2 = 1, State3 = 2, } int byteState1 = 1 Unity的Layer使用的也是位运算，有32个层 使用位运算能降低GC，还可以降低客户端和服务器之间的通讯量，只用一个整形可以表达32个状态 Day6 容器的内存分配 题目 一共有三次 List的底层原理 List的本质是对数组的封装 创建List的时候，实质是创建了一个数组，数组的初始容量是4 添加新的元素时，首先会检查数组的容量够不够 如果不够，会对数组进行扩容，此处产生了new 因为创建list分配了一次内存空间，创建int又分配了一次内存空间，而添加数组元素时已经超过了List原来的数组初始容量，所以第三次分配内存空间 如何利用这个特性 初始化的时候给予一个初始化容量，此容量要控制本对象生命周期中所固定的大小。容量本身可以大一些。 其他容器的本质也是一样的 List aList = new List(100); Dictionary dict = new Dictionary(100); Day7 面试题集合01 1、Position赋值问题 ​ 错误 原因： transfom.positions是一个Vector3类型的结构体，该结构体中的x，y，z没有setter，不能直接修改。 需要修改成。 Vector3 position = transform.position; transform.position = new Vector3(position.x,20,position.z); 2、Trigger问题 0次 原因： 这里并没有说明物体上是否有Rigidbody。必须要有Rigidbody，才会触发碰撞事件。 3、方向问题 错误 原因： 因为目标物体减去当前物体的位置，并不是方向的单位向量，需要进行归一化，才能得到方向向量。 transform.position = transform.position + (target.position - transform.position).Normalized * moveSpeed * Time.deltaTime; 优化上题代码 向量乘以数值乘以了两次，效率低，需要减少其乘法次数，尽量少在Update()里使用。 transform.position = transform.position + (target.position - transform.position).Normalized * (moveSpeed * Time.deltaTime); 这样每一帧只会进行一次乘法运算。 4、不同时间的区别 区别是： Time.unscaledDeltaTime 为上一帧到这一帧的准确的时间间隔 Time.deltaTime 则等于Time.unscaledDeltaTime * Time.timeScale Time.time 是指从游戏开始到现在的时间，会受到时间暂停的影响 Time.realtimeSinceStartUp 是指从游戏开始到现在的真实时间 5、距离计算问题 ​ 错误 原因： 如单纯只是使用距离大小进行比较，不要使用Vector3.Distance()，因为它是求平方根得到具体的值，效率低，在Update()中要减少使用。 可以使用Vector3.SqrMagnitud()作为判断的方式，因为该方法求出的是距离的平方，不需要开方操作，而比较距离的话只需比较距离的平方就能得出结果。 该题可以替换成： Vector3.sqrMagnitud(target - transform.position)>2*2//(题目中Distance距离的平方) 6、脚本运行顺序问题 ​ A按脚本顺序 原因： 按脚本顺序，A的Awake()以后立刻是A的OnEnable()，注意Start()另当别论（如果是Start()则是像第二种情况，所以的Awake()执行完后就去执行它们的Start()) 7、Int最大值溢出问题 ​ B 原因： 存储Int使用32位进制数，其中第一位表示符号，加1后溢出，符号取反，直接就变成了int.MinValue，也就是-(2^32) 8、遮挡渲染问题 ​ 不会 原因： 因为会进行深度测试，B的顶点按深度全部都在A后面，全部都没通过设置，所以就不渲染了。 上题续问 ​ 执行了 DrawCall介绍： DrawCall就是一个命令，从CPU发起，GPU接收。这个命令指向一个被需要渲染的图元（primitives）列表，告诉GPU开始进行一个渲染过程。 CPU和GPU并行工作 使用一个命令缓冲区（Command Buffer），CPU添加命令，GPU读取命令。命令有多种，DrawCall就是其中一种，其他命令还有改变渲染状态等。 原因： 经过深度测试使得B没渲染出来，但是深度测试本身就是一个执行Drawcall的过程，很明显B的shader已经运行过了，当然它的drawcall执行了。我们需要使用别的手段来剔除B，减少其消耗（比如遮挡剔除Occlusion Culling等等）。 Day8 面试题集合02 1、多线程方法使用问题 ​ BCD 原因： 在UnityEngine这个命名空间下的脚本，基本都不能在主线程之外使用，只能在主线程中使用。 2、脚本无法挂载问题 ​ Unity中的脚本名和脚本中的类名不一致 原因： 大部分情况下这是因为此脚本文件名与类名不一致导致的。这是Unity当初设计的一个约定，说起来应该算是一个设计缺陷，但它就是这样设计的，新手很容易遇到这个问题。 3、渲染性能问题 解答： Overdraw指的是过度绘制，也就是同一个屏幕像素被绘制了太多次数。 Text尽量少用官方Outline（描边）组件（Outline会做八次取样，相同的像素会叠八次），Image的Mask尽量不使用（会增加整个一层的Overdraw，还会增加一个Drawcall），使用RectMask2D，减少粒子发生器的数量，减少半透明物体等（不透明物体很容易通过Occlusion Culling深度剔除），半透明物体通常都是用在混合显示的时候。 4、数组优化问题 ​ B 原因： 因为A中的List没有预先定义容器的容量，如内部容器容量不够了就会进行扩容，每次扩容都会产生GC。 5、摄像机控制问题 ​ B 原因： LateUpdate()始终发生在Update()之后，在一帧的渲染当中，LateUpdate()几乎是最后执行的。 FixedUpdate()按固定时间间隔进行更新。 因为Update()中的顺序是随机的，有可能摄像机所在的Update()先于物体运动的Update()，显示的结果可能就是错误的。 LateUpdate()能保证在Update()后执行，放在这其中是最合适的。 6、UV取色问题 ​ 白色 原因： 这里取颜色主要取决于Wrap Mode，Repeated是平铺，Clamp是拉伸。 UV取色坐标超过1以后，如何采样取决于贴图采样的策略。如果是Repeated，则不考虑整数部分，（1.2,1.2）等价于（0.2,0.2）。但选择Clamp则意味着超过0，1范围的坐标点会被截断到最大值，因此返回的颜色是白色。 UV是什么： 就是贴图映射到模型表面的依据。 UV是一个坐标系统，U和V分别代表图片在Screen的水平和垂直方向上的坐标，这些坐标通常位于（0,0）和（1,1）之间 U：水平方向的第U个像素/图片高度 V：垂直方向的第V个像素/图片高度 最常见的UV用法是UV贴图 多边型除了具有三维的空间坐标外还有一个二维的UV坐标（（它和空间模型的X，Y，Z轴是类似的），以便把多边形的顶点和图片上的像素对应起来。这个UV纹理贴图定义了图片上每个点的位置的信息（即可以拿到任意一个像素的信息），这些点与3D模型是相互联系的，以决定表面纹理贴图的位置。也就是将图像上每一个点精准对应到模型物体的表面，在点与点之间的间隙位置由软件进行图像光滑插值处理。 7、C++嵌入问题 解答： 想要跨平台运行C++的代码，则将源码编译为对应平台的执行代码后才行。 如果要做Unity里调用C++的库，其原理并没有什么区别。同样的，先做C++的编译，然后再在Unity里进行对应平台的调用。 举例，mac平台下，C++代码编译为.bundle，放到plugins/x64目录下，这时unity里写一个对应的dllImport（库文件名），并且将其方法定义写出来，就可以像调用普通函数一样调用了。 [DllImport(\"PluginName\")] --PluginName为类库的名字 private static extern float FooPluginFunction(); 8、代码生成3D图像 解答： 这个面试题需要使用代码进行绘制。首先将扇形中轴线以扇面法线方向为轴，逆时针旋转扇形总角度的1/2，得到扇形起始边的方向。 将这些总角度分为n份，从0到n-1遍历，则可以轻易算出扇形的的顶点位置（起始点+方向*半径）。将圆心位置和这些顶点位置放在一个顶点数组里。 创建mesh，mesh的顶点数组已经算好了，接下来是三角形顶点id数组。这个很好求，继续遍历，0，i+1，i+2，这就是每个1/n角的三角形顶点id。 然后用代码新建一个空物体，添加meshRender，meshFitler上的Mesh赋值为刚才创建的mesh，并换上目标材质即可。 9、材质球数量问题 ​ 2份 原因： 预制体实例化过程中，因为预制体中的材质，所有的属性都是一样的，unity将它们设置为同一个材质球。所以A1和A2此时的材质球都是完全相同的，当对A1进行Shader.SetFloat后，A1的材质发生了变化，不能再使用之前共享的材质球，所以A1复制出来之前的材质球，并且给它赋予了新的值。现在就有A1特殊的材质球，和A2原本共享的材质球。 10、计算点在平面上投影的坐标 解答： P-A得到AP，这个值是A到P的方向向量。使用N*AP得到点积，此点积除以N的长度，再取绝对值，就可以得到点P到平面的垂直距离dP。 如果点积结果为正，则P-N×dP=PO，如果结果为负，则P+N×dP=PO（法线方向需要做归一化）。 Day9 面试题集合03 1、避免装箱问题 ​ B 解答： B有装箱操作。将值类型的数据赋值给object对象，则值类型转化为引用类型，为了保存引用，此处产生了gc，影响帧率稳定，所以要避免装箱。 设计API时尽量避免使用object做参数，可以用泛型来处理。 2、获取组件消耗问题 提示：Camera.main是取当前的主相机。 原因： Camera.main在游戏中是可以动态变化的。为了保证结果正确，这个函数内部使用的是FindGameObjectWithTag方法，会遍历场景中的所有节点，消耗很大。 避免方法： 将其缓存，比如在Awake当中获取此相机并保存起来，下次调用直接使用缓存过后的，避免相机在不改变数据的情况下的消耗。 3、迭代列表修改问题 B 过程分析： i=0 list={0,1,2,3} list[i] = 0 i=1 list={1,2,3} list[i] = 2 i=2 list={1,2,3} list[i] = 3 list={1,2} 尽量不要在迭代过程中修改列表数量，其结果是不可控的。 如要修改，可以采用倒序修改，或先把需要删除的筛选出来。 4、修饰符的使用问题 （一般考修饰符不会考public private partial） 解答： Protected表面作用域范围是当前类及派生类。 Internal表面作用域范围是本程序集，也就是如果打成了dll文件进行调用，那么调用处是无法访问到这些内容的。 Sealed表面这个类是最后一个派生类，即无法继续继承下去，不能拥有自己的子类。 5、面向对象原则（设计模式） 解答： S.O.L.I.D S：单一职责：设计的类，接口，对象等等，都只有一个单独的职责。 O：开闭原则：对修改关闭，对扩展开放。 L：里氏替换原则：子类可以扩展父类的功能，但不能修改父类的功能。 I：接口隔离原则：一个接口应该只有一个方法。 D：依赖倒置原则：高层不应该依赖于底层，高层和底层都应该依赖于抽象。抽象不应该依赖于细节，细节应该依赖于抽象。 以抽象为基础搭建起来的架构比以细节为基础搭建起来的架构要稳定的多。 抽象指的是接口或者抽象类，细节就是具体的实现类，使用接口或者抽象类的目的是制定好规范和契约，而不去设计任何具体的操作，把展现细节的人物交给它们的实现类取完成。 依赖倒置原则的核心思想是面向接口编程，可以降低程序之间的耦合度。参照Unity学习笔记中的C#语言学习中的接口举例。 迪米特法则：知道得越少越好。即一个类应该保存对其他对象最小的程度的了解。对接口通讯即可。 合成复用法则：组合优于基础，能用组合的地方不要用基础。 组合/聚合关系和继承关系 组合/聚合可以使系统更加灵活，降低类与类之间的耦合度，一个类的变化对其他类造成的影响相对较少；其次才考虑继承，在使用继承时，需要严格遵循里氏代换原则，有效使用继承会有助于对问题的理解，降低复杂度。 继承带来的问题： 继承复用会破坏系统的封装性，因为继承会将基类的实现细节暴露给子类，由于基类的内部细节通常对于子类来说是可见的，所以这种复用又称“白箱”复用，如果基类发生改变，那么子类的实现也不得不发生改变；从基类继承而来的实现是静态的，不可能在运行时发生改变，没有足够灵活性；而且继承只能在有限的环境中使用（如类没有声明不能被继承） 具体可以查看： 面向对象设计原则（六）合成复用原则 http://t.csdn.cn/LkuCT 6、欧拉角过渡问题 "}}